package 双序列型;

/**
 * 【双序列型】
 * 给定字符串 S 和 T, 计算 S 的所有子序列中有多少个 T.
 * 子序列字符串是原始字符串删除一些(或零个)字符之后得到的字符串, 并且要求剩下的字符的相对位置不能改变. (比如 "ACE" 是 ABCDE 的一个子序列, 而 "AEC" 不是)
 *
 * 双序列型dp，dp[i][j]代表S的前i个字符和T的前j个字符，假设现在到了最后一步，T中放进最后一个字符符，要看这个字符在不在S中
 * 假设的S的长度为n，T的长度为m
 *      1、T中此时放的最后一个字符就是S目前1最后一个字符，满足条件S[n-1] == T[m-1]，只要看前面S[0~n-2]和T[0~m-2]
 *      2、T中此时放的最后一个字符不在S中，S[n-1] != T[m-1]那就相当于A当前这个字符是废的，只要看前面S[0~n-2]和T[0~m-1]
 * dp[i][j] = dp[i-1][j-1]|S[i-1]=T[j-1] + dp[i-1][j]
 *
 * 这个题和LCS很相似，LCS是要考虑B的最后一个字符在不在最长公共子序列中，，但这个题，B本身就是最长公共子序列，B所有字符都在里头
 * 关键是以B为出发点
 */


public class _118_不同的子序列 {

    public int numDistinct(String S, String T) {
        int n = S.length();
        int m = T.length();
        int[][] dp = new int[n + 1][m + 1];

        //初始化，如果S是空串，但是T不是空串，那么出现次数为0
        for (int j = 0; j <= m; j++) {
            dp[0][j] = 0;
        }
        //初始化，如果S不是空串，但是T是空串，出现次数为1
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 1;
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                //初始值就是不想等的情况
                dp[i][j] = dp[i - 1][j];
                if (S.charAt(i - 1) == T.charAt(j - 1)) {
                    dp[i][j] += dp[i - 1][j - 1];
                }
            }
        }
        return dp[n][m];
    }
}